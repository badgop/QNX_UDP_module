/*
 * times_wrapper.cpp
 *
 *  Created on: 10.09.2021
 *      Author: tatarchuk
 */

#include "times_wrapper.h"


// flag - лучше установить 0 как указано п примерах, описания флагов смотри - neutrino.h строка 342
// notifyType = SIGEV_PULSE , остальные варианты см. <sys/siginfo.h> - тип уведомления от таймера, проще - пульс, с кодом пульса
// priorityType = 0  - см. примеры QNX
// sigevCodein - A code to be interpreted by the pulse handler. Although sigev_code can be any 8-bit signed value, you should
//avoid sigev_code values less than zero in order to avoid conflict with kernel or pulse codes generated by a QNX manager.
//These codes all start with _PULSE_CODE_ and are defined in <sys/neutrino.h>; for more information, see the documentation for the _pulse
//structure. A safe range of pulse values is _PULSE_CODE_MINAVAIL to _PULSE_CODE_MAXAVAIL.
// sigevCodein - КАЖДОМУ ТАЙМЕРУ СВОЁ ЧИСЛО


Timer :: Timer(uint8_t flag,uint32_t notifyType, uint32_t priorityType, uint8_t sigevCodein)
{
	   int32_t rez;
	   timerChid = ChannelCreate(flag); // создаем канал для обмена сообщением между программой и потоком таймера
	   timerEvent.sigev_notify		= notifyType;
	   timerEvent.sigev_coid		= ConnectAttach(ND_LOCAL_NODE, 0, timerChid, _NTO_SIDE_CHANNEL, 0); // настраиваем связь по каналу
	   timerEvent.sigev_priority	= getprio(priorityType);
	   timerEvent.sigev_code		=    sigevCodein;
	   sigevCode                    =   sigevCodein;
	   errorCreate = false;
	   rez = timer_create(CLOCK_REALTIME, &timerEvent, &timerTimer_id); // создаем таймер

	   if (rez == -1 )
		   errorCreate = true;
}

//startsec - время в секундах после которого таймер НАЧНЕТ работу
// startnsec - время в НАНОсекундах после которого таймер НАЧНЕТ работу - ДОЛЖНО БЫТЬ НЕНУЛЕЫМ, ИНАЧЕ таймер не начнет работу
// [0 - (1млрд -1)]
//repeatsec - время работы таймера в секундах
// repeatnsec - время работы таймеры в НАНОсекундах [0 - (1млрд -1)]

int32_t Timer :: start(uint32_t startsec, uint32_t startnsec,uint32_t repeatsec, uint32_t repeatnsec )
{
		struct itimerspec       itime;
		itime.it_value.tv_sec = startsec;
		itime.it_value.tv_nsec = startnsec;
		itime.it_interval.tv_sec = repeatsec;
		itime.it_interval.tv_nsec = repeatnsec;
		return timer_settime(timerTimer_id, 0, &itime, NULL);
}

// функция для ожидания срабатывания таймера
int32_t Timer :: checkTime()
{
	 // ждем сообщения от ПОТОКА в котором крутиться таймер
	 timerRcvid = MsgReceive(timerChid, &timerPulse, sizeof(timerPulse), NULL);
	    if (timerRcvid == 0)
	    {
	    	if (timerPulse.code == sigevCode ) // если приняли сообщение от таймера с нужным кодом то завершаем ожидание
	    	{
	           return 0;
	        }
	    }
	    return 1;
}

Timer :: ~Timer()
{
		ConnectDetach(timerEvent.sigev_coid);
		ChannelDestroy(timerChid);
		timer_delete(timerTimer_id);

}
